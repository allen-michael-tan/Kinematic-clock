# Kinematic Clock

This repository showcases how Singapore Polytechnic MakerSpace's kinematic clock was made.  

The design follows the Clockception instructables guide made by [madebymorgan](https://www.instructables.com/Clockception-How-to-Build-a-Clock-Made-From-Clocks/), where some aspects of the design were modified. 

## 3D Design

Before fabrication, all components were modelled in Autodesk Inventor Professional. The inventor files can be found [here](https://github.com/allen-michael-tan/Kinematic-clock/tree/main/Inventor%20files)

In this design, each digit will be represented using 6 individual smaller clocks, 24 clocks were needed to display 4 digits. The colour scheme used in the design is black and white.

### Clock design

<img src="https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20cad%201.jpg" alt="Clock cad 1" width="360"> <img src="https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20cad%202.jpg" alt="Clock cad 2" width="360" height="430.66">

The design of the individual clock bodies is shown above. 

### Board design

In addition to having a board to mount the clocks onto, 4 smaller boards are included in the design to raise the board forward, giving it a floating illusion when mounted onto a wall. 

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%201.jpg" alt="Board cad 1">

This is the front view of the board. 

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%202.jpg" alt="Board cad 2">

This is the back view of the board.

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%203.jpg" alt="Board cad 3">

These are the smaller boards attached to the back of the main board, they are offseted inwards to give the floating illusion when the board is mounted onto a wall.

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%204.jpg" alt="Board cad 4">

The above shows the assembly of the smaller boards onto the back of the main board. In the actual piece, they will be screwed into the main board using self tapping wood screws and L brackets. 

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Full%20cad%201.jpg" alt="Full cad 1">

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Full%20cad%202.jpg" alt="Full cad 2">

The above shows the respective front and back views of the full assembly of the kinematic clock in 3D CAD.

## Clock Assembly
Each clock is made up of: 

![Clock parts](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20parts.jpg)

1. Clock body [1]
2. Servo gear [2]
3. M2x12 pan head self-tapping screw [4]
4. M2x8 flanged pan head self-tapping screw [2]
5. Minute hand gear [1]
6. Hour hand gear [1]
7. Hour hand shaft [1]
8. Minute hand [1]
9. Hour hand [1]
10. Continuous servo motor [2]
11. M3 plain washer [3]
12. Bamboo skewer [1]
13. Retaining ring [1]  

### Parts manufacturing

The components of each clock were created using 3D printers, laser cutters and vinyl stickers.

#### 3D print

![3D printed part 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/3D%20printed%20part%201.jpeg)

![3D printed part 2 (clock body)]()

Majority of the clock parts were 3D printed with PLA material.

#### Laser cut

![Laser cut parts](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Laser%20cut%20parts.jpeg)

Flat parts such as clock hands and hour retaining ring were made with laser cut 2mm black coloured acrylic. 

#### Vinyl sticker

![Vinyl sticker](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Vinyl%20sticker.jpeg)

In order to allow for uniformity across all the clock faces, white vinyl stickers were cut and applied onto each clock face. 

### Pre-assembly preparation

Before each clocks were put together, some components of the clock had to be prepared first.

#### Coating of 3D printed parts

![Spray coating](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Spray%20coating.jpeg)

The material used for all 3D printed parts was PLA. This material has the tendency to disintigrate after a period of time, so a clear coat was applied on all the printed parts to increase their longevity. 

#### Hour hand assembly

![Hour hand assembly](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Hour%20hand%20assembly.jpg)

The laser cut hour hand (blue arrow) was superglued to the tip of the hour hand shaft as shown above.

#### Minute hand assembly

![Minute hand assembly 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Minute%20hand%20assembly%201.jpeg)

3mm thick bamboo skewers were cut into lengths of 60mm.

![Minute hand assembly 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Minute%20hand%20assembly%202.jpg)

M3 plain washer was superglued to the underside of the laser cut minute hand (blue arrow), this is done so to minimize friction between the minute and hour hand as they rotate. 

After which, a bamboo skewer was inserted to the minute hand and superglued (green arrow).

![Minute hand assembly 3](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Minute%20hand%20assembly%203.jpg)

Lastly, on the other side of the minute hand where the bamboo skewer was inserted, black paint is applied onto the exposed side of the skewer (blue arrow). 

### Assembly

#### Step 1

![Clock assembly 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%201.jpg)

The colour theme of the clock was black and white - black board and clock hands, white clock face. As the clock bodies were printed in different colours, white vinyl stickers were cut out and pasted onto the outside face of the clock body (blue arrow). 

*****

#### Step 2

![Clock assembly 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%202.jpg)

Next, two continuous servo motors were installed onto the clock body as shown above and secured using 4 screws (blue arrows).

*****

#### Step 3

![Clock assembly 3](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%203.jpeg)

Before inserting the hour hand, the shaft hub was lubricated using WD 40 to reduce friction between the hour hand shaft and the clock body.

*****

#### Step 4

![Clock assembly 4](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%204.jpg)

The hour hand was inserted as shown (blue arrow). 

*****

#### Step 5

![Clock assembly 5](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%205.jpg)

After the hour hand has been inserted, a retaining ring (blue arrow) was inserted as shown to prevent he hour hand from falling off. 

Following that, the hour hand gear (yellow arrow) and a servo gear (green arrow) was assembled accordingly. Then, a screw is used to secure the servo gear to the servo motor. 

*****

#### Step 6

![Clock assembly 6](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%206.jpg)

In this final step, the minute hand (yellow arrow) was inserted into the hour hand shaft, followed by two washers (green arrow) and minute hand gear (blue arrow).

It is important to note that, the before inserting the minute hand gear, the bamboo skewer should rotate freely with little friction whilst inserted in the hour hand shaft. This is because if there was too much friction, when the hour hand rotates, the minute hand will rotate along it which is undesired. 

The purpose of the washer is to prevent the bamboo skewer from jiggling in and out the hour hand shaft.

Lastly, a second servo gear (red arrow) is secured to the second servo motor with a screw as shown.  

## Board

The main board was made out of 15mm thick plywood. The parts were cut using a 2D CNC router. 

#### Step 1

The file of the boards were exported as dxf files then inserted into the versa cut software for the 2D CNC router to be prepared and cut. 

![CNC cutting 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/CNC%20cutting%201.jpeg)

2D router cutting the outline of the board.

![CNC cutting 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/CNC%20cutting%202.jpeg)

Once the cutting was finished, pieces of the board were removed from the raw material by chiseling them out. 

****

#### Step 2

![Sand + wood filler](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Sand%20%2B%20wood%20filler.jpeg)

The board pieces were repeatedly sanded to achieve a smooth finish, wood filler was applied to damaged areas that requried repairs. After applying the wood filler, the board pieces were sanded once more.

****

#### Step 3

![Predrill](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Predrill.jpeg)

Pilot holes for the mounting of the clocks were pre-drilled as shown.

****

#### Step 4

![Painting 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Painting%201.jpeg)

Once the surface of the board pieces were sanded smooth and all necessary pilot holes were drilled, all pieces were hand painted in black colour. 

![Painting 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Painting%202.jpeg)

A total of three coats were applied, with light sanding being done in between each coat of paint. 

****

#### Step 5

Once all the board pieces were painted black, two coats of clear lacquer was spray painted evenly on all the pieces to protect and give the wood a shiny finish. 

****

#### Step 6

![Assembly 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Assembly%201.jpg)

Once the lacquer had finished drying, it was time to assemble all the board pieces together. They are assembled as whown above. Wood screws were used to mount the smaller board pieces onto the main clock board. Furthermore, L brackets (blue arrows) were used to hold the smaller board pieces together. 

****

#### Step 7

![Assembly 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Assembly%202.jpeg)

Finally, all the clocks are screwed onto the back of the main board following the pre-drilled holes in step 3. 

****

#### Step 8

![Acrylic cover](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Acrylic%20cover.jpg)

To protect the front side of clock, a 3mm clear piece of acrylic sheet was screwed onto the clock as a cover. 

## Wiring

To control the 48 servo motors, three PWM servo motor drivers were used. Modifications to the two of the three drivers were done before they could all be daisy-chained together.

![Servo boards connection](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Servo%20boards%20connection.jpg)

For board two, A0 was bridged; while for board three, A1 was bridged. The boards were then connected as shown.

![Servos to board 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Servos%20to%20board%201.jpg)

Each driver board will control 16 individual motors, its wiring to the board is as shown. The remaining motors were wired exactly the same way as this board.

![Wiring of clock hands 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Wiring%20of%20clock%20hands%201.jpg)

The servo motors of each individual minute and hour hands were wired to each resepctive boards with reference to the table above. "M" refers to minute hand while "H" refers to hour hand. 

![Wiring of clock hands 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Wiring%20of%20clock%20hands%202.jpg)

The above shows how the clocks are grouped from the front. 

![Boards connection](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Boards%20connection.jpg)

A real time clock (RTC) module, DS3231 was used to accurately calculate the time displayed by the servo motors. 

The wiring connection of all the different boards is as of above. *(click image to see which ports need to be connected.)*

![Full schematic](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Full%20schematic.jpg)

This is the full schematic diagram of the kinematic clock.

![Cable clip](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Cable%20clip.jpg)

For cable management, cable organisers shown above was designed and 3D printed. It has a hole in the flat side where a screw can go through and secure it to the wood.

![Using cable clip](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Using%20cable%20clip.jpg)

This was how the cable organisers were used.

![Circuit board](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Circuit%20board.jpeg)

A circuit board was made to make the system modular should any replacement work is needed.

![Mounting of boards](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Mounting%20of%20boards.jpeg)

All the different circuit boards were adhered onto the back of the board with double-sided foam tape. 

![Final wiring](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Final%20wiring.jpeg)

This is how the back of the clock looked like after everything is wired and assembled. 

## Programming

### Calibration

Before writing the full code of the clock, the position of each individual hands of each clocks were first calibrated. After that, another code is used to calibrate the numbers, ensuring the hands can display the desired digit as accurately as possible. 

#### Position calibration

	#include <Wire.h>
	#include <Adafruit_PWMServoDriver.h>
	
	Adafruit_PWMServoDriver board1 = Adafruit_PWMServoDriver(0x40);
	Adafruit_PWMServoDriver board2 = Adafruit_PWMServoDriver(0x41);
	Adafruit_PWMServoDriver board3 = Adafruit_PWMServoDriver(0x42);
	
	#define SERVOMIN  544 // This is the 'minimum' pulse length count (out of 4096)
	#define SERVOMAX  2400// This is the 'maximum' pulse length count (out of 4096)
	//#define USMIN  600 // This is the rounded 'minimum' microsecond length based on the minimum pulse of 150
	//#define USMAX  2400 // This is the rounded 'maximum' microsecond length based on the maximum pulse of 600
	#define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates
	
	int number; // number command 
	
	void setup() {  
	
	  Serial.begin(9600); // initialize Serial connection
	  
	  board1.begin();  // Initialize servo ccontrol boards 
	  board2.begin();
	  board3.begin();
	  board1.setOscillatorFrequency(27000000);
	  board2.setOscillatorFrequency(27000000);
	  board3.setOscillatorFrequency(27000000);
	  board1.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates
	  board2.setPWMFreq(SERVO_FREQ); 
	  board3.setPWMFreq(SERVO_FREQ); 
	  
	  Serial.println("Ready for command");
	  
	  yield();
	}
	
	void loop() { 
	
	  while(Serial.available()>1){ // See if a command has been sent
	    number = Serial.parseInt(); // Turn command into integer
	    Serial.print(number);
	    Serial.println(" sent");
	    angleToPulse(number);
	  }
	  delay(100);
	}
	
	void angleToPulse(int ang){
	   int pulse1 = map(ang,0, 180, SERVOMIN,SERVOMAX); // Map angle of 0 to 180 to Servo min and Servo max 
	   int pulse2 = int(float(pulse1) / 1000000 * SERVO_FREQ * 4096);
	   Serial.print("Angle: ");Serial.print(ang);
	   Serial.print(" pulse: ");Serial.println(pulse2);
	   board1.setPWM(0 , 0, pulse2); // Change board number and servo number (first number in the bracket) based on which servo number and its corresponding board is being used.
	   delay(100);
	}

The above was the code used to calibrate the position of the hour and minute hands of the clocks. The process is explained below:

1. In the main void loop, the line - "board1.setPWM(0, 0, pulse2)" was modified constantly based on which clock's clock hand was being calibrated at the time. For example, if board two's (servo driver board) third servo is being calibrated, the line is as such - "board**2**.setPWM(**2**, 0, pulse2)".
2. The code was uploaded and run.
3. In the serial monitor, "Ready for command" was shown.
4. When a value of "120" was sent to the servo, the hour hand moved to its corresponding 120 position.
5. The hour hand was physically rotated towards the 12 o'clock position without rotating the servo motor.
6. After the hour hand was adjusted, a value of "80" was sent to the servo, where the hand moved in a clockwise direction.
6. Values between "120" and "80" were sent to the servo until the hour hand corresponded to 12 o'clock position accurately. That value was noted down in the [excel sheet](https://drive.google.com/file/d/1sLUSswgiBBg3gsoc3c7aR3SdEHQj8qRx/view?usp=sharing) in the C2 hour CCW column.
7. For the 3 o'clock position, values around "80" were modified until the hand correspnded to the 3 o'clock position from the clockwise direction accurately. That value was noted in the table's C2 hour CW column.
8. Similarly, for the 6 and 9 o'clock positions, values around "40" and "10" were sent to the servo until the values of the desired positions for both timings were obtained and noted in the C2 hour CW column for 6 and 9 o'clock respectively.
9. The 7.5 o'clock position was automatically calculated once the 6 and 9 o'clock positions were obtained.
10. Since all the 3D printed gears were not perfect, steps 5 to 10 were repeated in the counter clockwise direction.
11. Once the first hour hand was calibrated, steps 1 to 10 were repeated for the next minute hand.
12. Finally steps 1 - 11 were repeated for the remaining 23 clocks.  

**Note: In the table of the excel sheet, some cells are greyed out, this is because those particular positions will not be needed.**

![Incomplete table](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Incomplete%20table.jpg)

This was the table in the excel sheet before calibration.

![Completed table](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Completed%20table.jpg)

The completed table is shown above.

#### Number calibration

	#include <Wire.h>
	#include <Adafruit_PWMServoDriver.h>
	
	Adafruit_PWMServoDriver board1 = Adafruit_PWMServoDriver(0x40);
	Adafruit_PWMServoDriver board2 = Adafruit_PWMServoDriver(0x41);
	Adafruit_PWMServoDriver board3 = Adafruit_PWMServoDriver(0x42);
	
	#define SERVOMIN  544 // This is the 'minimum' pulse length count (out of 4096)
	#define SERVOMAX  2400// This is the 'maximum' pulse length count (out of 4096)
	//#define USMIN  600 // This is the rounded 'minimum' microsecond length based on the minimum pulse of 150
	//#define USMAX  2400 // This is the rounded 'maximum' microsecond length based on the maximum pulse of 600
	#define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates
	
	int number; // Number command 
	
	void setup() {  
	
	  Serial.begin(9600); 
	  
	  board1.begin();  // Initialize servo ccontrol boards 
	  board2.begin();
	  board3.begin();
	  board1.setOscillatorFrequency(27000000);
	  board2.setOscillatorFrequency(27000000);
	  board3.setOscillatorFrequency(27000000);
	  board1.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates
	  board2.setPWMFreq(SERVO_FREQ); 
	  board3.setPWMFreq(SERVO_FREQ); 
	  
	  Serial.println("Ready for command");
	  
	  yield();
	}
	
	void loop() {  
	
	  while(Serial.available()>0){  // See if a command has been sent
	    number = Serial.parseInt(); // Turn command into integer
	    Serial.print(number);
	    Serial.println(" sent");
	    digit2(number); // Change between digit1 - digit4, depending on which digit is being calibrated
	  }
	  delay(1000);
	}
	
	int angleToPulse(int ang){
	  int pulse1 = map(ang,0, 180, SERVOMIN,SERVOMAX); // Map angle of 0 to 180 to Servo min and Servo max 
	  int pulse2 = int(float(pulse1) / 1000000 * SERVO_FREQ * 4096);
	  Serial.print("Angle: ");Serial.print(ang);
	  Serial.print(" pulse: ");Serial.println(pulse2);
	  return pulse2;
	}
	
	/*1st digit*/
	
	void digit1(int number) {
	  if (number == 11) {
	    board1.setPWM(5, 0, angleToPulse(72));delay(200);
	    board1.setPWM(4, 0, angleToPulse(40));delay(200);
	    board1.setPWM(3, 0, angleToPulse(116));delay(200);
	    board1.setPWM(2, 0, angleToPulse(40));delay(200);
	    board1.setPWM(1, 0, angleToPulse(119));delay(200);
	    board1.setPWM(0, 0, angleToPulse(88));delay(200);
	    board1.setPWM(11, 0, angleToPulse(53));delay(200);
	    board1.setPWM(10, 0, angleToPulse(8));delay(200);
	    board1.setPWM(9, 0, angleToPulse(110));delay(200);
	    board1.setPWM(8, 0, angleToPulse(38));delay(200);
	    board1.setPWM(7, 0, angleToPulse(120));delay(200);
	    board1.setPWM(6, 0, angleToPulse(16));delay(200);
	  }
	  else if (number == 1) {
	    board1.setPWM(5, 0, angleToPulse(16));delay(200);
	    board1.setPWM(4, 0, angleToPulse(19));delay(200);
	    board1.setPWM(3, 0, angleToPulse(20));delay(200);
	    board1.setPWM(2, 0, angleToPulse(19));delay(200);
	    board1.setPWM(1, 0, angleToPulse(19));delay(200);
	    board1.setPWM(0, 0, angleToPulse(30));delay(200);
	    board1.setPWM(11, 0, angleToPulse(52));delay(200);
	    board1.setPWM(10, 0, angleToPulse(41));delay(200);
	    board1.setPWM(9, 0, angleToPulse(110));delay(200);
	    board1.setPWM(8, 0, angleToPulse(38));delay(200);
	    board1.setPWM(7, 0, angleToPulse(120));delay(200);
	    board1.setPWM(6, 0, angleToPulse(125));delay(200);
	  }
	  else if (number == 2) {
	    board1.setPWM(5, 0, angleToPulse(73));delay(200); 
	    board1.setPWM(4, 0, angleToPulse(76));delay(200);
	    board1.setPWM(3, 0, angleToPulse(79));delay(200);
	    board1.setPWM(2, 0, angleToPulse(39));delay(200);
	    board1.setPWM(1, 0, angleToPulse(119));delay(200);
	    board1.setPWM(0, 0, angleToPulse(88));delay(200);
	    board1.setPWM(11, 0, angleToPulse(53));delay(200); 
	    board1.setPWM(10, 0, angleToPulse(8));delay(200);
	    board1.setPWM(9, 0, angleToPulse(112));delay(200);
	    board1.setPWM(8, 0, angleToPulse(1));delay(200);
	    board1.setPWM(7, 0, angleToPulse(15));delay(200);
	    board1.setPWM(6, 0, angleToPulse(16));delay(200);
	  }
	}
	
	/*2nd digit*/
	
	void digit2(int number) {
	  if (number == 11) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(46));delay(200); 
	    board1.setPWM(15, 0, angleToPulse(120));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(45));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(78));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);
	    board2.setPWM(6, 0, angleToPulse(6));delay(200);
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(46));delay(200);
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	  else if (number == 1) {
	    board2.setPWM(1, 0, angleToPulse(33));delay(200);
	    board2.setPWM(0, 0, angleToPulse(29));delay(200);
	    board1.setPWM(15, 0, angleToPulse(25));delay(200);
	    board1.setPWM(14, 0, angleToPulse(26));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(27));delay(200);
	    board1.setPWM(12, 0, angleToPulse(21));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);  
	    board2.setPWM(6, 0, angleToPulse(37));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(46));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(125));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(120));delay(200);
	  }
	  else if (number == 2) {
	    board2.setPWM(1, 0, angleToPulse(87));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(79));delay(200); 
	    board1.setPWM(15, 0, angleToPulse(81));delay(200);
	    board1.setPWM(14, 0, angleToPulse(44));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(83));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);
	    board2.setPWM(5, 0, angleToPulse(122));delay(200);
	    board2.setPWM(4, 0, angleToPulse(11));delay(200);
	    board2.setPWM(3, 0, angleToPulse(18));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	  else if (number == 3) {
	    board2.setPWM(1, 0, angleToPulse(87));delay(200);
	    board2.setPWM(0, 0, angleToPulse(79));delay(200);
	    board1.setPWM(15, 0, angleToPulse(82));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(79));delay(200);
	    board1.setPWM(13, 0, angleToPulse(79));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(84));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(44));delay(200); 
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);  
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(13));delay(200); 
	  }
	  else if (number == 4) {
	    board2.setPWM(1, 0, angleToPulse(53));delay(200);
	    board2.setPWM(0, 0, angleToPulse(47));delay(200);
	    board1.setPWM(15, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(79));delay(200);
	    board1.setPWM(13, 0, angleToPulse(27));delay(200);
	    board1.setPWM(12, 0, angleToPulse(20));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200); 
	    board2.setPWM(6, 0, angleToPulse(37));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200);
	    board2.setPWM(4, 0, angleToPulse(45));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(125));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(120));delay(200);
	  }
	  else if (number == 5) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(45));delay(200); 
	    board1.setPWM(15, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(80));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(78));delay(200);
	    board1.setPWM(12, 0, angleToPulse(82));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(12));delay(200);
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);
	    board2.setPWM(5, 0, angleToPulse(49));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(124));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(14));delay(200); 
	  }
	  else if (number == 6) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200);
	    board2.setPWM(0, 0, angleToPulse(45));delay(200);
	    board1.setPWM(15, 0, angleToPulse(120));delay(200);
	    board1.setPWM(14, 0, angleToPulse(44));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(120));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(78));delay(200);
	    board2.setPWM(7, 0, angleToPulse(12));delay(200);
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);
	    board2.setPWM(5, 0, angleToPulse(49));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200);
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200); 
	  }
	  else if (number == 7) {
	    board2.setPWM(1, 0, angleToPulse(87));delay(200);
	    board2.setPWM(0, 0, angleToPulse(79));delay(200);
	    board1.setPWM(15, 0, angleToPulse(25));delay(200);
	    board1.setPWM(14, 0, angleToPulse(26));delay(200);
	    board1.setPWM(13, 0, angleToPulse(27));delay(200);
	    board1.setPWM(12, 0, angleToPulse(21));delay(200);
	    board2.setPWM(7, 0, angleToPulse(43));delay(200);
	    board2.setPWM(6, 0, angleToPulse(6));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200);
	    board2.setPWM(4, 0, angleToPulse(45));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(125));delay(200);
	    board2.setPWM(2, 0, angleToPulse(120));delay(200);
	  }
	  else if (number == 8) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200);
	    board2.setPWM(0, 0, angleToPulse(46));delay(200);
	    board1.setPWM(15, 0, angleToPulse(120));delay(200);
	    board1.setPWM(14, 0, angleToPulse(80));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(83));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200); 
	    board2.setPWM(6, 0, angleToPulse(6));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200);
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	  else if (number == 9) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(46));delay(200);
	    board1.setPWM(15, 0, angleToPulse(120));delay(200);
	    board1.setPWM(14, 0, angleToPulse(80));delay(200);
	    board1.setPWM(13, 0, angleToPulse(79));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(84));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);
	    board2.setPWM(6, 0, angleToPulse(6));delay(200);
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(45));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	}
	
	/*3rd digit*/
	
	void digit3(int number) {
	  if (number == 0) {
	    board2.setPWM(13, 0, angleToPulse(86.5));delay(200);
	    board2.setPWM(12, 0, angleToPulse(53));delay(200);
	    board2.setPWM(11, 0, angleToPulse(120));delay(200);
	    board2.setPWM(10, 0, angleToPulse(52));delay(200);
	    board2.setPWM(9, 0, angleToPulse(124));delay(200);
	    board2.setPWM(8, 0, angleToPulse(85));delay(200);
	    board2.setPWM(15, 0, angleToPulse(43));delay(200);
	    board2.setPWM(14, 0, angleToPulse(18));delay(200); 
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(46));delay(200);
	    board3.setPWM(3, 0, angleToPulse(125.5));delay(200); 
	    board3.setPWM(2, 0, angleToPulse(24));delay(200);
	  }
	  else if (number == 1) {
	    board2.setPWM(13, 0, angleToPulse(32));delay(200);
	    board2.setPWM(12, 0, angleToPulse(33));delay(200);
	    board2.setPWM(11, 0, angleToPulse(32));delay(200);
	    board2.setPWM(10, 0, angleToPulse(35));delay(200);
	    board2.setPWM(9, 0, angleToPulse(38));delay(200);
	    board2.setPWM(8, 0, angleToPulse(30));delay(200);
	    board2.setPWM(15, 0, angleToPulse(42));delay(200);
	    board2.setPWM(14, 0, angleToPulse(52));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(46));delay(200);
	    board3.setPWM(3, 0, angleToPulse(125));delay(200);
	    board3.setPWM(2, 0, angleToPulse(124));delay(200);
	  }
	  else if (number == 2) {
	    board2.setPWM(13, 0, angleToPulse(86));delay(200); 
	    board2.setPWM(12, 0, angleToPulse(90.5));delay(200);  
	    board2.setPWM(11, 0, angleToPulse(83));delay(200);
	    board2.setPWM(10, 0, angleToPulse(50));delay(200); 
	    board2.setPWM(9, 0, angleToPulse(124.5));delay(200); 
	    board2.setPWM(8, 0, angleToPulse(83.5));delay(200); 
	    board2.setPWM(15, 0, angleToPulse(43));delay(200); 
	    board2.setPWM(14, 0, angleToPulse(18));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(12));delay(200);
	    board3.setPWM(3, 0, angleToPulse(27));delay(200);
	    board3.setPWM(2, 0, angleToPulse(24));delay(200);
	  }
	  else if (number == 3) {
	    board2.setPWM(13, 0, angleToPulse(86));delay(200);
	    board2.setPWM(12, 0, angleToPulse(90));delay(200);
	    board2.setPWM(11, 0, angleToPulse(83));delay(200); 
	    board2.setPWM(10, 0, angleToPulse(87));delay(200);
	    board2.setPWM(9, 0, angleToPulse(91));delay(200);
	    board2.setPWM(8, 0, angleToPulse(84));delay(200); 
	    board2.setPWM(15, 0, angleToPulse(43));delay(200);
	    board2.setPWM(14, 0, angleToPulse(18));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(12));delay(200);
	    board3.setPWM(3, 0, angleToPulse(125));delay(200);
	    board3.setPWM(2, 0, angleToPulse(22));delay(200);
	  }
	  else if (number == 4) {
	    board2.setPWM(13, 0, angleToPulse(49));delay(200);
	    board2.setPWM(12, 0, angleToPulse(54));delay(200);
	    board2.setPWM(11, 0, angleToPulse(120));delay(200);
	    board2.setPWM(10, 0, angleToPulse(86));delay(200);
	    board2.setPWM(9, 0, angleToPulse(38));delay(200);
	    board2.setPWM(8, 0, angleToPulse(30));delay(200);
	    board2.setPWM(15, 0, angleToPulse(42));delay(200); 
	    board2.setPWM(14, 0, angleToPulse(52));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(47));delay(200); 
	    board3.setPWM(3, 0, angleToPulse(126));delay(200);
	    board3.setPWM(2, 0, angleToPulse(124));delay(200);  
	  }
	  else if (number == 5) {
	    board2.setPWM(13, 0, angleToPulse(86.5));delay(200); 
	    board2.setPWM(12, 0, angleToPulse(53));delay(200);
	    board2.setPWM(11, 0, angleToPulse(120));delay(200);
	    board2.setPWM(10, 0, angleToPulse(86));delay(200); 
	    board2.setPWM(9, 0, angleToPulse(90));delay(200);
	    board2.setPWM(8, 0, angleToPulse(85));delay(200);
	    board2.setPWM(15, 0, angleToPulse(8));delay(200);
	    board2.setPWM(14, 0, angleToPulse(21));delay(200);
	    board3.setPWM(1, 0, angleToPulse(49));delay(200); 
	    board3.setPWM(0, 0, angleToPulse(16));delay(200); 
	    board3.setPWM(3, 0, angleToPulse(125));delay(200);
	    board3.setPWM(2, 0, angleToPulse(24));delay(200);
	  }
	}
	
	/*4th digit*/
	
	void digit4(int number) {
	  if (number == 0) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200); 
	    board3.setPWM(8, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(7, 0, angleToPulse(116));delay(200);
	    board3.setPWM(6, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(115));delay(200);
	    board3.setPWM(4, 0, angleToPulse(89));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(23));delay(200);
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(59));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(117));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(21));delay(200); 
	  }
	  else if (number == 1) {
	    board3.setPWM(9, 0, angleToPulse(28));delay(200);
	    board3.setPWM(8, 0, angleToPulse(36));delay(200);
	    board3.setPWM(7, 0, angleToPulse(36.5));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(33.5));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(32));delay(200);   
	    board3.setPWM(4, 0, angleToPulse(33));delay(200);
	    board3.setPWM(15, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(51));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(60));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(119));delay(200); 
	  }
	  else if (number == 2) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(87.5));delay(200);
	    board3.setPWM(7, 0, angleToPulse(82));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(50));delay(200);
	    board3.setPWM(5, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(88));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(24));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(53));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(122));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(27));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(20));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(22));delay(200); 
	  }
	  else if (number == 3) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(87.5));delay(200);
	    board3.setPWM(7, 0, angleToPulse(82));delay(200);
	    board3.setPWM(6, 0, angleToPulse(86));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(85));delay(200);
	    board3.setPWM(4, 0, angleToPulse(88));delay(200);
	    board3.setPWM(15, 0, angleToPulse(23));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(53));delay(200);
	    board3.setPWM(13, 0, angleToPulse(122));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(27));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200);
	    board3.setPWM(10, 0, angleToPulse(21));delay(200);
	  }
	  else if (number == 4) {
	    board3.setPWM(9, 0, angleToPulse(43));delay(200); 
	    board3.setPWM(8, 0, angleToPulse(56));delay(200);
	    board3.setPWM(7, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(87));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(32));delay(200);
	    board3.setPWM(4, 0, angleToPulse(33));delay(200);
	    board3.setPWM(15, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(51));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(60));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(119));delay(200); 
	  }
	  else if (number == 5) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200);
	    board3.setPWM(7, 0, angleToPulse(116));delay(200);
	    board3.setPWM(6, 0, angleToPulse(87));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(85));delay(200);
	    board3.setPWM(4, 0, angleToPulse(88));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(24));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(21));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(52));delay(200);
	    board3.setPWM(12, 0, angleToPulse(24));delay(200);  
	    board3.setPWM(11, 0, angleToPulse(118));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(22));delay(200);
	  }
	  else if (number == 6) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200);
	    board3.setPWM(7, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(114));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(89));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(23));delay(200);
	    board3.setPWM(14, 0, angleToPulse(21));delay(200);
	    board3.setPWM(13, 0, angleToPulse(52));delay(200);
	    board3.setPWM(12, 0, angleToPulse(24));delay(200);
	    board3.setPWM(11, 0, angleToPulse(118));delay(200);
	    board3.setPWM(10, 0, angleToPulse(22));delay(200);
	  }
	  else if (number == 7) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(87.5));delay(200);
	    board3.setPWM(7, 0, angleToPulse(36.5));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(33.5));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(32));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(33));delay(200);
	    board3.setPWM(15, 0, angleToPulse(243));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200);
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(59));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200);
	    board3.setPWM(10, 0, angleToPulse(119));delay(200);
	  }
	  else if (number == 8) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(7, 0, angleToPulse(116));delay(200);
	    board3.setPWM(6, 0, angleToPulse(86.5));delay(200);
	    board3.setPWM(5, 0, angleToPulse(117));delay(200);
	    board3.setPWM(4, 0, angleToPulse(88));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(23));delay(200);
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200);
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(28));delay(200);
	    board3.setPWM(11, 0, angleToPulse(117));delay(200);
	    board3.setPWM(10, 0, angleToPulse(21));delay(200); 
	  }
	  else if (number == 9) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(7, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(86.5));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(85));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(88));delay(200);  
	    board3.setPWM(15, 0, angleToPulse(23));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200);
	    board3.setPWM(12, 0, angleToPulse(59));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(117));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(21));delay(200); 
	  }
	}

With the position of each clock hands calibrated, the clock could theorectically be used right away, however further fine adjustments to the servo motors were required to ensure the digits are as accurate as possible.

The code above is used to further calibrate the position of the hour and minute hands of the clocks to accurately display the desired digits. The process is explained below:

1. In the main void loop, the line - "digit2(number)" was changed between "1" to "4" based on which digit was being calibrated. 
2. For digits 2 and 4 of the clock, numbers "0" to "9" was required to be calibrated, while digit 1 only needed "0" to "2", and finally digit 3 needed "0" to "5".
3. For example, to calibrate the number "1" of the digit 1, the value of angle for the motors involved to make up that digit was changed slightly until the general shape of the number is as close to what a digital clock would display.
4. The process was repeated for all the remaining numbers and digits.

![Before number cali](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Before%20number%20cali.jpeg)

![After number cali](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/After%20number%20cali.jpeg)

Here is a before (top) and after (bottom) picture of the calibration of the number six.

### Code

All the codes used in this project can be found [here](https://github.com/allen-michael-tan/Kinematic-clock/tree/main/code).

#### Real Time Clock (RTC) code

The RTC module used is called DS3231, the code is as of below. 

	#include <Wire.h>
	#include "RTClib.h"
	
	RTC_DS3231 rtc;
	
	char daysOfTheWeek[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
	
	void setup () 
	{
	  Serial.begin(9600);
	  
	  delay(3000); // wait for console opening
	
	  if (! rtc.begin()) {
	    Serial.println("Couldn't find RTC");
	    while (1);
	  }
	
	  if (rtc.lostPower()) {
	    Serial.println("RTC lost power, lets set the time!");
	  
	    // Comment out below lines once you set the date & time. Following line sets the RTC to the date & time this sketch was compiled
	    // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
	  
	    // Following line sets the RTC with an explicit date & time, for example to set July 8 2021 at 13:30 you would call:
	    // rtc.adjust(DateTime(2021, 7, 8, 13, 30, 0));
	  }
	
	  // When time needs to be re-set on a previously configured device, the following line sets the RTC to the date & time this sketch was compiled
	  rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
	  // This line sets the RTC with an explicit date & time, for example to set July 8, 2021 at 13: you would call:
	  rtc.adjust(DateTime(2021, 7, 8, 13, 28, 0));
	}
	
	void printTime() {
	  
		DateTime now = rtc.now();
	    
	    Serial.print("Current Date & Time: ");
	    Serial.print(now.year(), DEC);
	    Serial.print('/');
	    Serial.print(now.month(), DEC);
	    Serial.print('/');
	    Serial.print(now.day(), DEC);
	    Serial.print(" (");
	    Serial.print(daysOfTheWeek[now.dayOfTheWeek()]);
	    Serial.print(") ");
	    Serial.print(now.hour(), DEC);
	    Serial.print(':');
	    Serial.print(now.minute(), DEC);
	    Serial.print(':');
	    Serial.print(now.second(), DEC);
	    Serial.println();
	    
	    delay(1000);
	}
	
	void loop () {
	    printTime();
	}

Before uploading the final code, this code was used to synchronise the time of the RTC to the current time. 

#### Full code

The code below is the final code used by the clock.

	#include <Wire.h>
	#include <Adafruit_PWMServoDriver.h>
	#include "RTClib.h"
	
	Adafruit_PWMServoDriver board1 = Adafruit_PWMServoDriver(0x40);
	Adafruit_PWMServoDriver board2 = Adafruit_PWMServoDriver(0x41);
	Adafruit_PWMServoDriver board3 = Adafruit_PWMServoDriver(0x42);
	
	#define SERVOMIN  544   // This is the 'minimum' pulse length count (out of 4096)
	#define SERVOMAX  2400  // This is the 'maximum' pulse length count (out of 4096)
	#define SERVO_FREQ 50   // Analog servos run at ~50 Hz updates
	
	RTC_DS3231 rtc;
	
	char daysOfTheWeek[7][12] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
	
	int hourPrevious;
	int hourCurrent;
	int minutePrevious;
	int minuteCurrent;
	
	int returndig1Previous;
	int returndig1Current;
	int returndig2;
	int returndig3Previous;
	int returndig3Current;
	int returndig4;
	
	void setup() {  
	  
	  Serial.begin(9600); 
	
	  /* Servo setup */
	
	  board1.begin();  // Initialize servo ccontrol boards
	  board2.begin();  
	  board3.begin();  
	  board1.setOscillatorFrequency(27000000);
	  board2.setOscillatorFrequency(27000000);
	  board3.setOscillatorFrequency(27000000);
	  board1.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates
	  board2.setPWMFreq(SERVO_FREQ); 
	  board3.setPWMFreq(SERVO_FREQ);
	  
	  yield();
	  
	  initialize();
	
	  /* RTC setup */
	
	  if (!rtc.begin()) {
	    Serial.println("Couldn't find RTC");
	    while (1);
	  }
	
	  if (rtc.lostPower()) {
	    Serial.println("RTC lost power, lets set the time!");
	  
	    // Comment out the two lines of code once the battery has been replaced and the date & time has been set.
	    // rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); // Sets the RTC to the date & time this sketch was compiled
	    // rtc.adjust(DateTime(2021, 7, 1, 14, 30, 0));    // Sets the RTC with an explicit date & time, this line sets to July 1 2021, 13:51
	  }
	
	  // To reset the time on a previously configured device, reupload this code to the device with the comments removed, then comment them again to avoid any unnecessary rtc reset.
	  // rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
	  // rtc.adjust(DateTime(2021, 7, 1, 14, 30, 0));
	} 
	
	void loop() {  
	  
	  DateTime now = rtc.now();     // Get the time from RTC
	
	  hourCurrent = now.hour();     // The current hour (0 - 23)
	  minuteCurrent = now.minute(); // The current minute (0 - 59)
	
	  if (hourCurrent != hourPrevious) {               // Check if the hour has changed
	    returndig1Current = hourCurrent / 10;          // Get the 1st digit of the hour
	    returndig2 = hourCurrent % 10;                 // Get the 2nd digit of the hour
	    if (returndig1Current != returndig1Previous) { // Check to see if the first digit has changed (2nd digit will always change)
	      digit1(returndig1Current);                   // Change digit 1 on the clock to a new number
	      returndig1Previous = returndig1Current;      // Store the new number
	    }
	    digit2(returndig2);                            // Change digit 2 on the clock to a new number
	    hourPrevious = hourCurrent;                    // Store the new number
	  }
	
	  if (minuteCurrent != minutePrevious) {           // Check if the minute has changed
	    returndig3Current = minuteCurrent / 10;        // Get the 1st digit of the minute
	    returndig4 = minuteCurrent % 10;               // Get the 2nd digit of the minute
	    if (returndig3Current != returndig3Previous) { // Check to see if the first digit has changed (2nd digit will always change)
	      digit3(returndig3Current);                   // Change digit 3 on the clock to a new number
	      returndig3Previous = returndig3Current;      // Store the new number
	    }
	    digit4(returndig4);                            // Change digit 4 on the clock to a new number
	    minutePrevious = minuteCurrent;                // Store the new number
	  }
	
	  delay(15000);                                    // Wait 15s to check if time has changed
	}
	
	/* Determining the angles in which the servos move at */
	
	int angleToPulse(int ang){
	   int pulse1 = map(ang,0, 180, SERVOMIN,SERVOMAX); // Map the angles of 0 to 180 to Servo min and Servo max 
	   int pulse2 = int(float(pulse1) / 1000000 * SERVO_FREQ * 4096);
	   // Serial.print("Angle: ");Serial.print(ang);
	   // Serial.print(" pulse: ");Serial.println(pulse);
	   return pulse2;
	}
	
	/* Actual clock initialization */
	
	void initialize() {
	  DateTime now = rtc.now(); // Get the time from RTC
	
	  hourCurrent = (now.hour(), DEC);     // The current hour (0 - 23)
	  minuteCurrent = (now.minute(), DEC); // The current minute (0 - 59)
	
	  // Serial.print(hourCurrent); Serial.print(":"); Serial.println(minuteCurrent);
	  
	  returndig1Current = hourCurrent / 10;   // get 1st digit of hour
	  returndig2 = hourCurrent % 10;          // get 2nd digit of hour
	  returndig3Current = minuteCurrent / 10; // get 1st digit of minute
	  returndig4 = minuteCurrent % 10;        // get 2nd digit of minute
	  
	  // Serial.print(returndig1Current); Serial.print(returndig2); Serial.print(returndig3Current); Serial.println(returndig4);
	
	  for (int dig1 = 0; dig1 <= 2; dig1++){                  // Cycle 1st digit from 0-2
	    digit1(dig1);
	    // Serial.println(dig1);
	    delay(100);
	  }
	  for (int dig1 = 0; dig1 <= returndig1Current; dig1++){  // Cycle 1st digit from 0 to current time 
	    digit1(dig1);
	    // Serial.println(dig1);
	    delay(100);
	  }
	  
	  for (int dig2 = 0; dig2 <= 9; dig2++){                  // Cycle 2nd digit from 0-9
	    digit2(dig2);
	    // Serial.println(dig2);
	    delay(100);
	  }
	  for (int dig2 = 0; dig2 <= returndig2; dig2++){         // Cycle 1st digit from 0 to current time
	    digit2(dig2);
	    // Serial.println(dig2);
	    delay(100);
	  }
	
	  for (int dig3 = 0; dig3 <= 5; dig3++){                  // Cycle 3rd digit from 0-5
	    digit3(dig3);
	    delay(100);
	  }
	  for (int dig3 = 0; dig3 <= returndig3Current; dig3++){  // Cycle 1st digit from 0 to current time
	    digit3(dig3);
	    delay(100);
	  }
	
	  for (int dig4 = 0; dig4 <= 9; dig4++){                  // Cycle 4th digit from 0-9
	    digit4(dig4);
	    delay(100);
	  }
	  for (int dig4 = 0; dig4 <= returndig4; dig4++){         // Cycle 1st digit from 0 to current time
	    digit4(dig4);
	    delay(100);
	  }
	}
	
	/*The code below are found in the Kinematic clock calibration excel file, under the sheet named "Calibrated digits"
	
	/*1st digit*/
	
	void digit1(int number) {
	  if (number == 0) {
	    board1.setPWM(5, 0, angleToPulse(72));delay(200);
	    board1.setPWM(4, 0, angleToPulse(40));delay(200); 
	    board1.setPWM(3, 0, angleToPulse(116));delay(200);
	    board1.setPWM(2, 0, angleToPulse(40));delay(200);
	    board1.setPWM(1, 0, angleToPulse(119));delay(200);
	    board1.setPWM(0, 0, angleToPulse(88));delay(200);
	    board1.setPWM(11, 0, angleToPulse(53));delay(200);
	    board1.setPWM(10, 0, angleToPulse(8));delay(200);
	    board1.setPWM(9, 0, angleToPulse(110));delay(200);
	    board1.setPWM(8, 0, angleToPulse(38));delay(200);
	    board1.setPWM(7, 0, angleToPulse(120));delay(200);
	    board1.setPWM(6, 0, angleToPulse(16));delay(200);
	  }
	  else if (number == 1) {
	    board1.setPWM(5, 0, angleToPulse(16));delay(200);
	    board1.setPWM(4, 0, angleToPulse(19));delay(200);
	    board1.setPWM(3, 0, angleToPulse(20));delay(200);
	    board1.setPWM(2, 0, angleToPulse(19));delay(200);
	    board1.setPWM(1, 0, angleToPulse(19));delay(200);
	    board1.setPWM(0, 0, angleToPulse(30));delay(200);
	    board1.setPWM(11, 0, angleToPulse(52));delay(200);
	    board1.setPWM(10, 0, angleToPulse(41));delay(200);
	    board1.setPWM(9, 0, angleToPulse(110));delay(200);
	    board1.setPWM(8, 0, angleToPulse(38));delay(200);
	    board1.setPWM(7, 0, angleToPulse(120));delay(200);
	    board1.setPWM(6, 0, angleToPulse(125));delay(200);
	  }
	  else if (number == 2) {
	    board1.setPWM(5, 0, angleToPulse(73));delay(200); 
	    board1.setPWM(4, 0, angleToPulse(76));delay(200);
	    board1.setPWM(3, 0, angleToPulse(79));delay(200);
	    board1.setPWM(2, 0, angleToPulse(39));delay(200);
	    board1.setPWM(1, 0, angleToPulse(119));delay(200);
	    board1.setPWM(0, 0, angleToPulse(88));delay(200);
	    board1.setPWM(11, 0, angleToPulse(53));delay(200); 
	    board1.setPWM(10, 0, angleToPulse(8));delay(200);
	    board1.setPWM(9, 0, angleToPulse(112));delay(200);
	    board1.setPWM(8, 0, angleToPulse(1));delay(200);
	    board1.setPWM(7, 0, angleToPulse(15));delay(200);
	    board1.setPWM(6, 0, angleToPulse(16));delay(200);
	  }
	}
	
	/*2nd digit*/
	
	void digit2(int number) {
	  if (number == 0) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(46));delay(200); 
	    board1.setPWM(15, 0, angleToPulse(120));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(45));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(78));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);
	    board2.setPWM(6, 0, angleToPulse(6));delay(200);
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(46));delay(200);
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	  else if (number == 1) {
	    board2.setPWM(1, 0, angleToPulse(33));delay(200);
	    board2.setPWM(0, 0, angleToPulse(29));delay(200);
	    board1.setPWM(15, 0, angleToPulse(25));delay(200);
	    board1.setPWM(14, 0, angleToPulse(26));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(27));delay(200);
	    board1.setPWM(12, 0, angleToPulse(21));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);  
	    board2.setPWM(6, 0, angleToPulse(37));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(46));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(125));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(120));delay(200);
	  }
	  else if (number == 2) {
	    board2.setPWM(1, 0, angleToPulse(87));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(79));delay(200); 
	    board1.setPWM(15, 0, angleToPulse(81));delay(200);
	    board1.setPWM(14, 0, angleToPulse(44));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(83));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);
	    board2.setPWM(5, 0, angleToPulse(122));delay(200);
	    board2.setPWM(4, 0, angleToPulse(11));delay(200);
	    board2.setPWM(3, 0, angleToPulse(18));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	  else if (number == 3) {
	    board2.setPWM(1, 0, angleToPulse(87));delay(200);
	    board2.setPWM(0, 0, angleToPulse(79));delay(200);
	    board1.setPWM(15, 0, angleToPulse(82));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(79));delay(200);
	    board1.setPWM(13, 0, angleToPulse(79));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(84));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(44));delay(200); 
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);  
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(13));delay(200); 
	  }
	  else if (number == 4) {
	    board2.setPWM(1, 0, angleToPulse(53));delay(200);
	    board2.setPWM(0, 0, angleToPulse(47));delay(200);
	    board1.setPWM(15, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(79));delay(200);
	    board1.setPWM(13, 0, angleToPulse(27));delay(200);
	    board1.setPWM(12, 0, angleToPulse(20));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200); 
	    board2.setPWM(6, 0, angleToPulse(37));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200);
	    board2.setPWM(4, 0, angleToPulse(45));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(125));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(120));delay(200);
	  }
	  else if (number == 5) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(45));delay(200); 
	    board1.setPWM(15, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(14, 0, angleToPulse(80));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(78));delay(200);
	    board1.setPWM(12, 0, angleToPulse(82));delay(200); 
	    board2.setPWM(7, 0, angleToPulse(12));delay(200);
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);
	    board2.setPWM(5, 0, angleToPulse(49));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(124));delay(200); 
	    board2.setPWM(2, 0, angleToPulse(14));delay(200); 
	  }
	  else if (number == 6) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200);
	    board2.setPWM(0, 0, angleToPulse(45));delay(200);
	    board1.setPWM(15, 0, angleToPulse(120));delay(200);
	    board1.setPWM(14, 0, angleToPulse(44));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(120));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(78));delay(200);
	    board2.setPWM(7, 0, angleToPulse(12));delay(200);
	    board2.setPWM(6, 0, angleToPulse(7));delay(200);
	    board2.setPWM(5, 0, angleToPulse(49));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200);
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200); 
	  }
	  else if (number == 7) {
	    board2.setPWM(1, 0, angleToPulse(87));delay(200);
	    board2.setPWM(0, 0, angleToPulse(79));delay(200);
	    board1.setPWM(15, 0, angleToPulse(25));delay(200);
	    board1.setPWM(14, 0, angleToPulse(26));delay(200);
	    board1.setPWM(13, 0, angleToPulse(27));delay(200);
	    board1.setPWM(12, 0, angleToPulse(21));delay(200);
	    board2.setPWM(7, 0, angleToPulse(43));delay(200);
	    board2.setPWM(6, 0, angleToPulse(6));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200);
	    board2.setPWM(4, 0, angleToPulse(45));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(125));delay(200);
	    board2.setPWM(2, 0, angleToPulse(120));delay(200);
	  }
	  else if (number == 8) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200);
	    board2.setPWM(0, 0, angleToPulse(46));delay(200);
	    board1.setPWM(15, 0, angleToPulse(120));delay(200);
	    board1.setPWM(14, 0, angleToPulse(80));delay(200); 
	    board1.setPWM(13, 0, angleToPulse(119));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(83));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200); 
	    board2.setPWM(6, 0, angleToPulse(6));delay(200); 
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(11));delay(200);
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	  else if (number == 9) {
	    board2.setPWM(1, 0, angleToPulse(88));delay(200); 
	    board2.setPWM(0, 0, angleToPulse(46));delay(200);
	    board1.setPWM(15, 0, angleToPulse(120));delay(200);
	    board1.setPWM(14, 0, angleToPulse(80));delay(200);
	    board1.setPWM(13, 0, angleToPulse(79));delay(200); 
	    board1.setPWM(12, 0, angleToPulse(84));delay(200);
	    board2.setPWM(7, 0, angleToPulse(44));delay(200);
	    board2.setPWM(6, 0, angleToPulse(6));delay(200);
	    board2.setPWM(5, 0, angleToPulse(122));delay(200); 
	    board2.setPWM(4, 0, angleToPulse(45));delay(200); 
	    board2.setPWM(3, 0, angleToPulse(124));delay(200);
	    board2.setPWM(2, 0, angleToPulse(14));delay(200);
	  }
	}
	
	/*3rd digit*/
	
	void digit3(int number) {
	  if (number == 0) {
	    board2.setPWM(13, 0, angleToPulse(86.5));delay(200);
	    board2.setPWM(12, 0, angleToPulse(53));delay(200);
	    board2.setPWM(11, 0, angleToPulse(120));delay(200);
	    board2.setPWM(10, 0, angleToPulse(52));delay(200);
	    board2.setPWM(9, 0, angleToPulse(124));delay(200);
	    board2.setPWM(8, 0, angleToPulse(85));delay(200);
	    board2.setPWM(15, 0, angleToPulse(43));delay(200);
	    board2.setPWM(14, 0, angleToPulse(18));delay(200); 
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(46));delay(200);
	    board3.setPWM(3, 0, angleToPulse(125.5));delay(200); 
	    board3.setPWM(2, 0, angleToPulse(24));delay(200);
	  }
	  else if (number == 1) {
	    board2.setPWM(13, 0, angleToPulse(32));delay(200);
	    board2.setPWM(12, 0, angleToPulse(33));delay(200);
	    board2.setPWM(11, 0, angleToPulse(32));delay(200);
	    board2.setPWM(10, 0, angleToPulse(35));delay(200);
	    board2.setPWM(9, 0, angleToPulse(38));delay(200);
	    board2.setPWM(8, 0, angleToPulse(30));delay(200);
	    board2.setPWM(15, 0, angleToPulse(42));delay(200);
	    board2.setPWM(14, 0, angleToPulse(52));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(46));delay(200);
	    board3.setPWM(3, 0, angleToPulse(125));delay(200);
	    board3.setPWM(2, 0, angleToPulse(124));delay(200);
	  }
	  else if (number == 2) {
	    board2.setPWM(13, 0, angleToPulse(86));delay(200); 
	    board2.setPWM(12, 0, angleToPulse(90.5));delay(200);  
	    board2.setPWM(11, 0, angleToPulse(83));delay(200);
	    board2.setPWM(10, 0, angleToPulse(50));delay(200); 
	    board2.setPWM(9, 0, angleToPulse(124.5));delay(200); 
	    board2.setPWM(8, 0, angleToPulse(83.5));delay(200); 
	    board2.setPWM(15, 0, angleToPulse(43));delay(200); 
	    board2.setPWM(14, 0, angleToPulse(18));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(12));delay(200);
	    board3.setPWM(3, 0, angleToPulse(27));delay(200);
	    board3.setPWM(2, 0, angleToPulse(24));delay(200);
	  }
	  else if (number == 3) {
	    board2.setPWM(13, 0, angleToPulse(86));delay(200);
	    board2.setPWM(12, 0, angleToPulse(90));delay(200);
	    board2.setPWM(11, 0, angleToPulse(83));delay(200); 
	    board2.setPWM(10, 0, angleToPulse(87));delay(200);
	    board2.setPWM(9, 0, angleToPulse(91));delay(200);
	    board2.setPWM(8, 0, angleToPulse(84));delay(200); 
	    board2.setPWM(15, 0, angleToPulse(43));delay(200);
	    board2.setPWM(14, 0, angleToPulse(18));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(12));delay(200);
	    board3.setPWM(3, 0, angleToPulse(125));delay(200);
	    board3.setPWM(2, 0, angleToPulse(22));delay(200);
	  }
	  else if (number == 4) {
	    board2.setPWM(13, 0, angleToPulse(49));delay(200);
	    board2.setPWM(12, 0, angleToPulse(54));delay(200);
	    board2.setPWM(11, 0, angleToPulse(120));delay(200);
	    board2.setPWM(10, 0, angleToPulse(86));delay(200);
	    board2.setPWM(9, 0, angleToPulse(38));delay(200);
	    board2.setPWM(8, 0, angleToPulse(30));delay(200);
	    board2.setPWM(15, 0, angleToPulse(42));delay(200); 
	    board2.setPWM(14, 0, angleToPulse(52));delay(200);
	    board3.setPWM(1, 0, angleToPulse(122));delay(200);
	    board3.setPWM(0, 0, angleToPulse(47));delay(200); 
	    board3.setPWM(3, 0, angleToPulse(126));delay(200);
	    board3.setPWM(2, 0, angleToPulse(124));delay(200);  
	  }
	  else if (number == 5) {
	    board2.setPWM(13, 0, angleToPulse(86.5));delay(200); 
	    board2.setPWM(12, 0, angleToPulse(53));delay(200);
	    board2.setPWM(11, 0, angleToPulse(120));delay(200);
	    board2.setPWM(10, 0, angleToPulse(86));delay(200); 
	    board2.setPWM(9, 0, angleToPulse(90));delay(200);
	    board2.setPWM(8, 0, angleToPulse(85));delay(200);
	    board2.setPWM(15, 0, angleToPulse(8));delay(200);
	    board2.setPWM(14, 0, angleToPulse(21));delay(200);
	    board3.setPWM(1, 0, angleToPulse(49));delay(200); 
	    board3.setPWM(0, 0, angleToPulse(16));delay(200); 
	    board3.setPWM(3, 0, angleToPulse(125));delay(200);
	    board3.setPWM(2, 0, angleToPulse(24));delay(200);
	  }
	}
	
	/*4th digit*/
	
	void digit4(int number) {
	  if (number == 0) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200); 
	    board3.setPWM(8, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(7, 0, angleToPulse(116));delay(200);
	    board3.setPWM(6, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(115));delay(200);
	    board3.setPWM(4, 0, angleToPulse(89));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(23));delay(200);
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(59));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(117));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(21));delay(200); 
	  }
	  else if (number == 1) {
	    board3.setPWM(9, 0, angleToPulse(28));delay(200);
	    board3.setPWM(8, 0, angleToPulse(36));delay(200);
	    board3.setPWM(7, 0, angleToPulse(36.5));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(33.5));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(32));delay(200);   
	    board3.setPWM(4, 0, angleToPulse(33));delay(200);
	    board3.setPWM(15, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(51));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(60));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(119));delay(200); 
	  }
	  else if (number == 2) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(87.5));delay(200);
	    board3.setPWM(7, 0, angleToPulse(82));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(50));delay(200);
	    board3.setPWM(5, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(88));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(24));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(53));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(122));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(27));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(20));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(22));delay(200); 
	  }
	  else if (number == 3) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(87.5));delay(200);
	    board3.setPWM(7, 0, angleToPulse(82));delay(200);
	    board3.setPWM(6, 0, angleToPulse(86));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(85));delay(200);
	    board3.setPWM(4, 0, angleToPulse(88));delay(200);
	    board3.setPWM(15, 0, angleToPulse(23));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(53));delay(200);
	    board3.setPWM(13, 0, angleToPulse(122));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(27));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200);
	    board3.setPWM(10, 0, angleToPulse(21));delay(200);
	  }
	  else if (number == 4) {
	    board3.setPWM(9, 0, angleToPulse(43));delay(200); 
	    board3.setPWM(8, 0, angleToPulse(56));delay(200);
	    board3.setPWM(7, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(87));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(32));delay(200);
	    board3.setPWM(4, 0, angleToPulse(33));delay(200);
	    board3.setPWM(15, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(51));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(60));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(119));delay(200); 
	  }
	  else if (number == 5) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200);
	    board3.setPWM(7, 0, angleToPulse(116));delay(200);
	    board3.setPWM(6, 0, angleToPulse(87));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(85));delay(200);
	    board3.setPWM(4, 0, angleToPulse(88));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(24));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(21));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(52));delay(200);
	    board3.setPWM(12, 0, angleToPulse(24));delay(200);  
	    board3.setPWM(11, 0, angleToPulse(118));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(22));delay(200);
	  }
	  else if (number == 6) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200);
	    board3.setPWM(7, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(114));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(89));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(23));delay(200);
	    board3.setPWM(14, 0, angleToPulse(21));delay(200);
	    board3.setPWM(13, 0, angleToPulse(52));delay(200);
	    board3.setPWM(12, 0, angleToPulse(24));delay(200);
	    board3.setPWM(11, 0, angleToPulse(118));delay(200);
	    board3.setPWM(10, 0, angleToPulse(22));delay(200);
	  }
	  else if (number == 7) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(87.5));delay(200);
	    board3.setPWM(7, 0, angleToPulse(36.5));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(33.5));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(32));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(33));delay(200);
	    board3.setPWM(15, 0, angleToPulse(243));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200);
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(59));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(118));delay(200);
	    board3.setPWM(10, 0, angleToPulse(119));delay(200);
	  }
	  else if (number == 8) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(7, 0, angleToPulse(116));delay(200);
	    board3.setPWM(6, 0, angleToPulse(86.5));delay(200);
	    board3.setPWM(5, 0, angleToPulse(117));delay(200);
	    board3.setPWM(4, 0, angleToPulse(88));delay(200); 
	    board3.setPWM(15, 0, angleToPulse(23));delay(200);
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200);
	    board3.setPWM(13, 0, angleToPulse(121));delay(200); 
	    board3.setPWM(12, 0, angleToPulse(28));delay(200);
	    board3.setPWM(11, 0, angleToPulse(117));delay(200);
	    board3.setPWM(10, 0, angleToPulse(21));delay(200); 
	  }
	  else if (number == 9) {
	    board3.setPWM(9, 0, angleToPulse(77));delay(200);
	    board3.setPWM(8, 0, angleToPulse(54));delay(200); 
	    board3.setPWM(7, 0, angleToPulse(116));delay(200); 
	    board3.setPWM(6, 0, angleToPulse(86.5));delay(200); 
	    board3.setPWM(5, 0, angleToPulse(85));delay(200); 
	    board3.setPWM(4, 0, angleToPulse(88));delay(200);  
	    board3.setPWM(15, 0, angleToPulse(23));delay(200); 
	    board3.setPWM(14, 0, angleToPulse(52.5));delay(200); 
	    board3.setPWM(13, 0, angleToPulse(121));delay(200);
	    board3.setPWM(12, 0, angleToPulse(59));delay(200); 
	    board3.setPWM(11, 0, angleToPulse(117));delay(200); 
	    board3.setPWM(10, 0, angleToPulse(21));delay(200); 
	  }
	}

## Final Product

Once the full code has been uploaded, the board was mounted onto the wall and plugged into the wall. 

![Final product](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Final%20product.jpeg)

<a href="https://www.youtube.com/watch?v=qirl-tjCUZg"><img src="http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg" 
alt="Youtube video of kinetic cloc"k wdthi="240" height="180" border="10" /></a> 

Here is a timelapse of the clock in action!