# Kinematic Clock

This repository showcases how Singapore Polytechnic MakerSpace's kinematic clock was made.  

The design follows the Clockception instructables guide made by [madebymorgan](https://www.instructables.com/Clockception-How-to-Build-a-Clock-Made-From-Clocks/), where some aspects of the design were modified. 

## 3D Design

Before fabrication, all components were modelled in Autodesk Inventor Professional. The inventor files can be found [here](https://github.com/allen-michael-tan/Kinematic-clock/tree/main/Inventor%20files)

In this design, each digit will be represented using 6 individual smaller clocks, 24 clocks were needed to display 4 digits. The colour scheme used in the design is black and white.

### Clock design

<img src="https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20cad%201.jpg" alt="Clock cad 1" width="360"> <img src="https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20cad%202.jpg" alt="Clock cad 2" width="360" height="430.66">

The design of the individual clock bodies is shown above. 

### Board design

In addition to having a board to mount the clocks onto, 4 smaller boards are included in the design to raise the board forward, giving it a floating illusion when mounted onto a wall. 

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%201.jpg" alt="Board cad 1">

This is the front view of the board. 

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%202.jpg" alt="Board cad 2">

This is the back view of the board.

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%203.jpg" alt="Board cad 3">

These are the smaller boards attached to the back of the main board, they are offseted inwards to give the floating illusion when the board is mounted onto a wall.

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Board%20cad%204.jpg" alt="Board cad 4">

The above shows the assembly of the smaller boards onto the back of the main board. In the actual piece, they will be screwed into the main board using self tapping wood screws and L brackets. 

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Full%20cad%201.jpg" alt="Full cad 1">

<img src = "https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Full%20cad%202.jpg" alt="Full cad 2">

The above shows the respective front and back views of the full assembly of the kinematic clock in 3D CAD.

## Clock Assembly
Each clock is made up of: 

![Clock parts](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20parts.jpg)

1. Clock body [1]
2. Servo gear [2]
3. M2x12 pan head self-tapping screw [4]
4. M2x8 flanged pan head self-tapping screw [2]
5. Minute hand gear [1]
6. Hour hand gear [1]
7. Hour hand shaft [1]
8. Minute hand [1]
9. Hour hand [1]
10. Continuous servo motor [2]
11. M3 plain washer [3]
12. Bamboo skewer [1]
13. Retaining ring [1]  

### Parts manufacturing

The components of each clock were created using 3D printers, laser cutters and vinyl stickers.

#### 3D print

![3D printed part 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/3D%20printed%20part%201.jpeg)

![3D printed part 2 (clock body)]()

Majority of the clock parts were 3D printed with PLA material.

#### Laser cut

![Laser cut parts](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Laser%20cut%20parts.jpeg)

Flat parts such as clock hands and hour retaining ring were made with laser cut 2mm black coloured acrylic. 

#### Vinyl sticker

![Vinyl sticker]()

In order to allow for uniformity across all the clock faces, white vinyl stickers were cut and applied onto each clock face. 

### Pre-assembly preparation

Before each clocks were put together, some components of the clock had to be prepared first.

#### Coating of 3D printed parts

![Spray coating](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Spray%20coating.jpeg)

The material used for all 3D printed parts was PLA. This material has the tendency to disintigrate after a period of time, so a clear coat was applied on all the printed parts to increase their longevity. 

#### Hour hand assembly

![Hour hand assembly](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Hour%20hand%20assembly.jpg)

The laser cut hour hand (blue arrow) was superglued to the tip of the hour hand shaft as shown above.

#### Minute hand assembly

![Minute hand assembly 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Minute%20hand%20assembly%201.jpeg)

3mm thick bamboo skewers were cut into lengths of 60mm.

![Minute hand assembly 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Minute%20hand%20assembly%202.jpg)

M3 plain washer was superglued to the underside of the laser cut minute hand (blue arrow), this is done so to minimize friction between the minute and hour hand as they rotate. 

After which, a bamboo skewer was inserted to the minute hand and superglued (green arrow).

![Minute hand assembly 3](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Minute%20hand%20assembly%203.jpg)

Lastly, on the other side of the minute hand where the bamboo skewer was inserted, black paint is applied onto the exposed side of the skewer (blue arrow). 

### Assembly

#### Step 1

![Clock assembly 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%201.jpg)

The colour theme of the clock was black and white - black board and clock hands, white clock face. As the clock bodies were printed in different colours, white vinyl stickers were cut out and pasted onto the outside face of the clock body (blue arrow). 

*****

#### Step 2

![Clock assembly 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%202.jpg)

Next, two continuous servo motors were installed onto the clock body as shown above and secured using 4 screws (blue arrows).

*****

#### Step 3

![Clock assembly 3](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%203.jpeg)

Before inserting the hour hand, the shaft hub was lubricated using WD 40 to reduce friction between the hour hand shaft and the clock body.

*****

#### Step 4

![Clock assembly 4](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%204.jpg)

The hour hand was inserted as shown (blue arrow). 

*****

#### Step 5

![Clock assembly 5](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%205.jpg)

After the hour hand has been inserted, a retaining ring (blue arrow) was inserted as shown to prevent he hour hand from falling off. 

Following that, the hour hand gear (yellow arrow) and a servo gear (green arrow) was assembled accordingly. Then, a screw is used to secure the servo gear to the servo motor. 

*****

#### Step 6

![Clock assembly 6](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Clock%20assembly%206.jpg)

In this final step, the minute hand (yellow arrow) was inserted into the hour hand shaft, followed by two washers (green arrow) and minute hand gear (blue arrow).

It is important to note that, the before inserting the minute hand gear, the bamboo skewer should rotate freely with little friction whilst inserted in the hour hand shaft. This is because if there was too much friction, when the hour hand rotates, the minute hand will rotate along it which is undesired. 

The purpose of the washer is to prevent the bamboo skewer from jiggling in and out the hour hand shaft.

Lastly, a second servo gear (red arrow) is secured to the second servo motor with a screw as shown.  

## Board

The main board was made out of 15mm thick plywood. The parts were cut using a 2D CNC router. 

#### Step 1

The file of the boards were exported as dxf files then inserted into the versa cut software for the 2D CNC router to be prepared and cut. 

![CNC cutting 1]()https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/CNC%20cutting%201.jpeg

2D router cutting the outline of the board.

![CNC cutting 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/CNC%20cutting%202.jpeg)

Once the cutting was finished, pieces of the board were removed from the raw material by chiseling them out. 

****

#### Step 2

![Sand + wood filler](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Sand%20%2B%20wood%20filler.jpeg)

The board pieces were repeatedly sanded to achieve a smooth finish, wood filler was applied to damaged areas that requried repairs. After applying the wood filler, the board pieces were sanded once more.

****

#### Step 3

![Predrill](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Predrill.jpeg)

Pilot holes for the mounting of the clocks were pre-drilled as shown.

****

#### Step 4

![Painting 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Painting%201.jpeg)

Once the surface of the board pieces were sanded smooth and all necessary pilot holes were drilled, all pieces were hand painted in black colour. 

![Painting 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Painting%202.jpeg)

A total of three coats were applied, with light sanding being done in between each coat of paint. 

****

#### Step 5

Once all the board pieces were painted black, two coats of clear lacquer was spray painted evenly on all the pieces to protect and give the wood a shiny finish. 

****

#### Step 6

![Assembly 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Assembly%201.jpg)

Once the lacquer had finished drying, it was time to assemble all the board pieces together. They are assembled as whown above. Wood screws were used to mount the smaller board pieces onto the main clock board. Furthermore, L brackets (blue arrows) were used to hold the smaller board pieces together. 

****

#### Step 7

![Assembly 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Assembly%202.jpeg)

Finally, all the clocks are screwed onto the back of the main board following the pre-drilled holes in step 3. 

## Wiring

To control the 48 servo motors, three PWM servo motor drivers were used. Modifications to the two of the three drivers were done before they could all be daisy-chained together.

![Servo boards connection](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Servo%20boards%20connection.jpg)

For board two, A0 was bridged; while for board three, A1 was bridged. The boards were then connected as shown.

![Servos to board 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Servos%20to%20board%201.jpg)

Each driver board will control 16 individual motors, its wiring to the board is as shown. The remaining motors were wired exactly the same way as this board.

![Wiring of clock hands 1](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Wiring%20of%20clock%20hands%201.jpg)

The servo motors of each individual minute and hour hands were wired to each resepctive boards with reference to the table above. "M" refers to minute hand while "H" refers to hour hand. 

![Wiring of clock hands 2](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Wiring%20of%20clock%20hands%202.jpg)

The above shows how the clocks are grouped from the front. 

![Boards connection](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Boards%20connection.jpg)

A real time clock (RTC) module, DS3231 was used to accurately calculate the time displayed by the servo motors. 

The wiring connection of all the different boards is as of above. *(click image to see which ports need to be connected.)*

![Full schematic](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Full%20schematic.jpg)

This is the full schematic diagram of the kinematic clock.

![Circuit board](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Circuit%20board.jpeg)

A circuit board was made to make the system modular should any replacement work is needed.

![Mounting of boards]()

All the different circuit boards were adhered onto the back of the board with double-sided foam tape. 

![Final wiring]()

This is how the back of the clock looked like after everything is wired and assembled. 

## Programming

### Calibration

Before the whole clock was coded, the position of the individual clocks was calibrated first to ensure they can accurately display the desired digit. 

#### Position calibration

		#include <Wire.h>
		#include <Adafruit_PWMServoDriver.h>

		Adafruit_PWMServoDriver board1 = Adafruit_PWMServoDriver(0x40);
		Adafruit_PWMServoDriver board2 = Adafruit_PWMServoDriver(0x41);
		Adafruit_PWMServoDriver board3 = Adafruit_PWMServoDriver(0x42);

		#define SERVOMIN  544 // This is the 'minimum' pulse length count (out of 4096)
		#define SERVOMAX  2400// This is the 'maximum' pulse length count (out of 4096)
		//#define USMIN  600 // This is the rounded 'minimum' microsecond length based on the minimum pulse of 150
		//#define USMAX  2400 // This is the rounded 'maximum' microsecond length based on the maximum pulse of 600
		#define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates

		int number; // number command 

		void setup() {  

			Serial.begin(9600); 

			board1.begin();  // Initialize servo control boards 
			board2.begin();
			board3.begin();
			board1.setOscillatorFrequency(27000000);
			board2.setOscillatorFrequency(27000000);
			board3.setOscillatorFrequency(27000000);
			board1.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates
			board2.setPWMFreq(SERVO_FREQ); 
			board3.setPWMFreq(SERVO_FREQ); 

			Serial.println("Ready for command");

			yield();
		}

		void loop() {  

			while(Serial.available()>1){ //see if a command has been sent
  				number = Serial.parseInt(); //turn command into integer
	  			Serial.print(number);
  				Serial.println(" sent");
  				angleToPulse(number);
			}
			delay(100);
		}

		void angleToPulse(int ang){
   		
			int pulse1 = map(ang,0, 180, SERVOMIN,SERVOMAX); // map angle of 0 to 180 to Servo min and Servo max 
   			int pulse2 = int(float(pulse1) / 1000000 * SERVO_FREQ * 4096);
   			Serial.print("Angle: ");Serial.print(ang);
   			Serial.print(" pulse: ");Serial.println(pulse2);
   			board3.setPWM(14, 0, pulse2);
   			delay(100);
		}

The above was the code used to calibrate the position of the hour and minute hands of the clocks. The process is explained below:

1. In the main void loop, modify the line of code for the lowest row first column clock hour hand (C1H per the naming convention). Replace the "3" with the board the hour hand is connected to, and replace the "14" with the pin number that hand is connected to, i.e. "board**3**.setPWM(**14**,0,pulse2);"
2. Run the code.
3. Check the serial monitor, it should read "Ready for command".
3. Send "120" to the servo, the hour hand should go to its corresponding 120 position.
4. Physically rotate the hour hand towards the 12 o'clock position.
5. Once the adjustment has been made, send "80" to the servo, the hand should move in a clockwise direction.
6. Switch between a command around "120" and the "80" command, and keep modfying the 120 number until a number command  that corresponds to 12 o'clock. Note the number in the [excel sheet](https://drive.google.com/file/d/1s7x2neyZYlE4V-eNKhpxrev4_VrFf_b3/view?usp=sharing) for the C1 hour CCW column.
7. Switch between the 12 value and something around "80" until the number for the 3 o'clock position from the clockwise direction is achieved. Note the number in the table in the C1 hour CW column.
8. Swith the 3 value and something around "40" number for the 6 o'clock position from the clockwise direction. Note the value in the table.
9. The 7.5 o'clock position is calculated in the table, so this position does not need to be calibrated.
10. Switch between the 6 value and something around "10" to get the value for the 9'oclock in the CCW direction, and note the value down.
11. As the gears are not perfect, repeat steps 5 to 10 in the counter clockwise direction. This is because the values will likely be a little different and each hand will need to hit the aforementioned position from both counter and clockwise directions for the various numbers. Once this is done, the one hand of the clock has been calibrated.
12. Modify the numbers in the "board**3**.setPWM(**14**,0,pulse2);" code for the C1 minute hand and repeat steps 2 to 11.
13. Once that is done, repeat steps 2 to 12 for the remaining 23 clocks.

**Note: In the table of the excel sheet, some cells are greyed out, this is because those particular positions will not be needed.**

![Incomplete table](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Incomplete%20table.jpg)

This was the table in the excel sheet before calibration.

![Completed table](https://github.com/allen-michael-tan/Kinematic-clock/blob/main/Images/Completed%20table.jpg)

The completed table is shown above.

#### Number calibration

		#include <Wire.h>
		#include <Adafruit_PWMServoDriver.h>

		Adafruit_PWMServoDriver board1 = Adafruit_PWMServoDriver(0x40);
		Adafruit_PWMServoDriver board2 = Adafruit_PWMServoDriver(0x41);
		Adafruit_PWMServoDriver board3 = Adafruit_PWMServoDriver(0x42);

		#define SERVOMIN  544 // This is the 'minimum' pulse length count (out of 4096)
		#define SERVOMAX  2400// This is the 'maximum' pulse length count (out of 4096)
		//#define USMIN  600 // This is the rounded 'minimum' microsecond length based on the minimum pulse of 150
		//#define USMAX  2400 // This is the rounded 'maximum' microsecond length based on the maximum pulse of 600
		#define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates

		int number; // number command 

		void setup() {  

			Serial.begin(9600); 

			board1.begin();  // Initialize servo ccontrol boards 
			board2.begin();
			board3.begin();
			board1.setOscillatorFrequency(27000000);
			board2.setOscillatorFrequency(27000000);
			board3.setOscillatorFrequency(27000000);
			board1.setPWMFreq(SERVO_FREQ);  // Analog servos run at ~50 Hz updates
			board2.setPWMFreq(SERVO_FREQ); 
			board3.setPWMFreq(SERVO_FREQ); 

			Serial.println("Ready for command");

			yield();
		}

		void loop() {  

			while(Serial.available()>0){ //see if a command has been sent
  				number = Serial.parseInt(); //turn command into integer
  				Serial.print(number);
 				Serial.println(" sent");
  				digit4(number);
			}
			delay(1000);
		}

		int angleToPulse(int ang){

   			int pulse1 = map(ang,0, 180, SERVOMIN,SERVOMAX); // map angle of 0 to 180 to Servo min and Servo max 
   			int pulse2 = int(float(pulse1) / 1000000 * SERVO_FREQ * 4096);
		   	Serial.print("Angle: ");Serial.print(ang);
   			Serial.print(" pulse: ");Serial.println(pulse2);
   			return pulse2;
		}

		void digit4(int number){
			if (number == 99) {
				board3.setPWM(6, 0, angleToPulse(39));delay(200);
				board3.setPWM(5, 0, angleToPulse(101));delay(200);
			}
			
			else if (number == 1) {
				board3.setPWM(11, 0, angleToPulse(40));delay(200);
				board3.setPWM(9, 0, angleToPulse(23));delay(200);
				board3.setPWM(8, 0, angleToPulse(17));delay(200);
				board3.setPWM(7, 0, angleToPulse(33));delay(200);
				board3.setPWM(6, 0, angleToPulse(24));delay(200);
				board3.setPWM(5, 0, angleToPulse(18));delay(200);
				board3.setPWM(4, 0, angleToPulse(18));delay(200);
				board3.setPWM(14, 0, angleToPulse(42));delay(200);
				board3.setPWM(10, 0, angleToPulse(102));delay(200);
				board3.setPWM(11, 0, angleToPulse(101));delay(200);
			}
			
			else if (number == 2) {
				board3.setPWM(9, 0, angleToPulse(75));delay(200);
				board3.setPWM(8, 0, angleToPulse(65));delay(200);
				board3.setPWM(7, 0, angleToPulse(88));delay(200);
				board3.setPWM(6, 0, angleToPulse(40));delay(200);
				board3.setPWM(5, 0, angleToPulse(100));delay(200);
				board3.setPWM(4, 0, angleToPulse(66));delay(200);
				board3.setPWM(14, 0, angleToPulse(7));delay(200);
				board3.setPWM(12, 0, angleToPulse(20));delay(200);
				board3.setPWM(11, 0, angleToPulse(4));delay(200);
				board3.setPWM(10, 0, angleToPulse(8));delay(200);
			}

			else if (number == 3) {
				board3.setPWM(6, 0, angleToPulse(75));delay(200);
				board3.setPWM(5, 0, angleToPulse(61));delay(200);
				board3.setPWM(11, 0, angleToPulse(103));delay(200);
			}	

			else if (number == 4) {
				board3.setPWM(11, 0, angleToPulse(40));delay(200);
				board3.setPWM(9, 0, angleToPulse(40));delay(200);
				board3.setPWM(8, 0, angleToPulse(32));delay(200);
				board3.setPWM(7, 0, angleToPulse(119));delay(200);
				board3.setPWM(5, 0, angleToPulse(18));delay(200);
				board3.setPWM(4, 0, angleToPulse(18));delay(200);
				board3.setPWM(14, 0, angleToPulse(42));delay(200);
				board3.setPWM(12, 0, angleToPulse(50));delay(200);
				board3.setPWM(10, 0, angleToPulse(102));delay(200);
				board3.setPWM(11, 0, angleToPulse(101));delay(200);
			}

			else if (number == 5) {
				board3.setPWM(9, 0, angleToPulse(76));delay(200);
				board3.setPWM(5, 0, angleToPulse(65));delay(200);
				board3.setPWM(4, 0, angleToPulse(66));delay(200);
				board3.setPWM(15, 0, angleToPulse(10));delay(200);
				board3.setPWM(14, 0, angleToPulse(8));delay(200);
				board3.setPWM(13, 0, angleToPulse(50));delay(200);
				board3.setPWM(12, 0, angleToPulse(18));delay(200);
				board3.setPWM(10, 0, angleToPulse(7));delay(200);
			}

			else if (number == 6) {
				board3.setPWM(6, 0, angleToPulse(40));delay(200);
				board3.setPWM(5, 0, angleToPulse(100));delay(200);
			}

			else if (number == 7) {
				board3.setPWM(11, 0, angleToPulse(40));delay(200);
				board3.setPWM(8, 0, angleToPulse(65));delay(200);
				board3.setPWM(7, 0, angleToPulse(33));delay(200);
				board3.setPWM(6, 0, angleToPulse(23));delay(200);
				board3.setPWM(5, 0, angleToPulse(18));delay(200);
				board3.setPWM(4, 0, angleToPulse(18));delay(200);
				board3.setPWM(15, 0, angleToPulse(48));delay(200);
				board3.setPWM(13, 0, angleToPulse(119));delay(200);
				board3.setPWM(12, 0, angleToPulse(50));delay(200);
				board3.setPWM(10, 0, angleToPulse(102));delay(200);
				board3.setPWM(11, 0, angleToPulse(101));delay(200);
			}


			else if (number == 8) {
				board3.setPWM(8, 0, angleToPulse(32));delay(200);
				board3.setPWM(7, 0, angleToPulse(118));delay(200);
				board3.setPWM(6, 0, angleToPulse(75));delay(200);
				board3.setPWM(5, 0, angleToPulse(100));delay(200);
				board3.setPWM(4, 0, angleToPulse(66));delay(200);
				board3.setPWM(12, 0, angleToPulse(20));delay(200);
				board3.setPWM(10, 0, angleToPulse(7));delay(200);
			}

			else if (number == 9) {
				board3.setPWM(6, 0, angleToPulse(76));delay(200);
				board3.setPWM(5, 0, angleToPulse(61));delay(200);
				board3.setPWM(12, 0, angleToPulse(48));delay(200);
			}
		}

### Code

#### Real Time Clock (RTC) code

The code below is for the DS3231 RTC module. 

		#include <Wire.h>
		#include <ds3231.h>
 
		struct ts t; 
 
		void setup() {
  		Serial.begin(9600);
  		Wire.begin();
  		DS3231_init(DS3231_CONTROL_INTCN);

		/*To synchronise the clock, insert the appropriate values below.*/ 

  		t.hour=12; 
  		t.min=30;
  		t.sec=0;
  		t.mday=25; 
  		t.mon=12;
  		t.year=2019;
 
  		DS3231_set(t); 
		}
 
		void loop() {
  		DS3231_get(&t);
  		Serial.print("Date : ");
  		Serial.print(t.mday);
  		Serial.print("/");
  		Serial.print(t.mon);
  		Serial.print("/");
  		Serial.print(t.year);
  		Serial.print("\t Hour : ");
  		Serial.print(t.hour);
  		Serial.print(":");
  		Serial.print(t.min);
  		Serial.print(".");
  		Serial.println(t.sec);
 
  		delay(1000);
		}

**_Note: For the actual clock, only the values for time is needed._**

#### Full code
		lmao

## Final Product

![Final product]()

<a href="https://www.youtube.com/watch?v=qirl-tjCUZg"><img src="http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg" 
alt="Youtube video of kinetic cloc"k wdthi="240" height="180" border="10" /></a> 